# JSON Web Token (JWT)

- JSON Web Token is basically an encoded long string of characters made up of 3 parts.
- It's worth noting that **JWTs operate in seconds (for example, expiresIn: seconds), whereas cookies work in milliseconds (maxAge: milliseconds).**

**JWT Architecture**  - ```JWT = Headers.payload.signature```

## 1. Token Headers
The first part of a JWT is the token headers. These headers typically consist of metadata for the token, providing information such as the type of signature used and the hashing algorithm employed.

## 2. Payload
- It contains the user data encoded within the JWT.
- When this payload will get decoded on the server, we know which user is going to be logged in.
- It's important that no sensitive data is put inside this payload, in case a token is compromised it can be decoded. 

## 3. Signature
- It makes the token secure (like a stamp of authenticity).
- Signature is used to verify the token on the server.
- **signature** = `Hashed together (Headers + payload + secret)`

# JWT Working

- When a user signs up, after validation, the server generates a JWT and attaches it to a cookie, then sends it to the client via response headers. This JWT contains crucial user information, like their ID, roles, etc, and is digitally signed by the server.

- Upon login, post-validation, a new JWT is generated by the server, replacing the old one. This updated JWT is sent to the client along with the cookie.

- The JWT contains the encoded data about that user to identify them, as long as they have this JWT in the cookie then they are considered as logged in and authenticated.

- When the server is creating jwt after a user successfully signup or login,
the server creates the header part and the payload part first and encodes them both.

- Now to add the signature, server takes both of these two parts (i.e header & payload)
and hashes them together with something called a `secret` which is a secure secret string stored on the server.

- Now, this secret must remain a secret because it's the key to unlocking the jwt and the only way to verify a token so you would never publish this secret to any kind of public repository where anyone could see it.

- So when those 3 things (i.e header , payload , secret string) hashed together , it creates a token signature, now this token signature is then added to the end of jwt after the other 2 parts (i.e header.payload.signature) and it can be sent to the browser.

- So our jwt is then added into a cookie and sent and stored in a browser, so for any subsequent request to the server , the jwt token is then received by the server inside that cookie.

- The server then can verify this token on every request by looking at the header and the payload and hashing them with the secret string (which remember is stored on the server).

- If the hashed value of header & payload with the secret matches the signature , then it knows that is's valid and the jwt has not been tampered on the client side.

- If the hashed value does not match with the signature , then the user is requested to log in again!































 




 